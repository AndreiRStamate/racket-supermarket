#lang racket
(require "queue.rkt" "supermarket.rkt")

; ignorați următoarele linii de cod...
(define show-defaults 999) ; câte exerciții la care s-au întors rezultate default să fie arătate detaliat
(define prepend #t) (define nopoints #f) (define name-ex '(testul testele trecut capitolul))
(define default-results `(#f 0 () your-code-here)) (define (default-result r) (set! default-results (cons r default-results))) (define : 'separator) (define punct 'string) (define puncte 'string) (define BONUS 'string) (define exerciții 'string)
(define total 0) (define all '()) (define n-ex 0) (define p-ex 0) (define n-exercs -1) (define default-returns '()) (define (ex n sep p . s) (set! n-ex n) (set! p-ex p) (set! all (cons (list n p) all))) (define exercițiul ex) (define (sunt n s) (set! n-exercs n)) (define s-a string-append)
(define (p . L) (map (λ (e) (display e) (when (> (string-length (format "~a" e)) 0) (display " "))) L) (newline)) (define (p-n-ex) (format "[~a]" (if nopoints (string-join (list (symbol->string (cadddr name-ex)) (number->string n-ex) "/" (number->string n-exercs))) n-ex)))
(define (epart ep% pfix full) (if (< (caddr ep%) 1) (s-a pfix (if full "" (s-a (symbol->string (car name-ex)) " ")) (if (and nopoints (not full)) "" (number->string n-ex)) (symbol->string (cadr ep%))) (if (and nopoints (not full)) "" (s-a pfix (if full "" (s-a (symbol->string (car name-ex)) " ")) (number->string n-ex)))))
(define (whengood ep%) (let [(pts (* p-ex (caddr ep%)))] (and (if prepend (printf "+~v: " pts) (printf "~a[OK] " (p-n-ex))) (if nopoints (p (epart ep% "" #f) "rezolvat") (p (epart ep% "" #f) "rezolvat: +" pts (if (= pts 1) 'punct 'puncte))) (set! total (+ total pts)))))
(define (whenbad ep% gvn expcd msg) (and (when (member gvn default-results) (set! default-returns (cons (epart ep% "" #t) default-returns))) (when (or (not (member gvn default-results)) (<= (length default-returns) show-defaults)) (bad-res ep% gvn expcd msg))))
(define (bad-res ep% gvn expcd msg) (p (if prepend "+0.0:" (format "~a[--]" (p-n-ex))) (epart ep% "la " #f) 'rezultatul gvn msg expcd))
(define (check-conds e gvn conds) (or (null? conds) (let ([r ((car conds) gvn)]) (if (eq? r #t) (check-conds e gvn (cdr conds)) (whenbad e gvn "" (or r "nu îndeplinește condiția"))))))
(define (check-part part per given main-test expected . conds) (let* ([e (list n-ex part per)] [p? (pair? (cdr main-test))] [p (if p? (car main-test) identity)] [t ((if p? cadr car) main-test)] [m ((if p? cddr cdr) main-test)]) (when (eq? #t (check-conds e given conds)) (if (t (p given) expected) (whengood e) (whenbad e (p given) expected m)))))
(define (check given main-test expected . conds) (apply check-part '- 1 given main-test expected conds))
(define the cons) (define is (cons equal? "diferă de cel așteptat")) (define in (cons member "nu se află printre variantele așteptate"))
(define same-set-as (cons (λ (x y) (apply equal? (map list->seteqv (list x y)))) "nu este aceeași mulțime cu"))
(define same-unique (cons (λ (x y) (and (apply = (map length (list x y))) ((car same-set-as) x y))) "nu sunt aceleași rezultate cu"))
(define (sumar) (when (and (not (null? default-returns)) (< show-defaults (length default-returns))) (p "... rezultatul implicit dat la" (cadr name-ex) (reverse default-returns))) (when (not nopoints) (p 'total: total 'puncte)))
(define (mark-helper) (printf "---~nEx  puncte    Total până aici~n") (foldr (λ (e-p t) (p (car e-p) ': (cadr e-p) "puncte. total 1 -" (car e-p) ': (+ t (cadr e-p))) (+ t (cadr e-p))) 0 all) (newline))


(sunt 7 exerciții)

(define (list->stream l)
  (if (null? l)
      empty-stream
      (stream-cons (car l) (list->stream (cdr l)))))

(define (new->legacy q)
  (struct-copy queue q
               [left (stream->list (queue-left q))]))

(define (friendly-output output)
  (cons (car output)
        (map (λ (pair) (cons (car pair) (new->legacy (cdr pair))))
             (cdr output))))
					
(define Q1 (make-queue empty-stream '() 0 0))
(define Q2 (make-queue (list->stream '(10 2 3)) '(60 5 40) 3 3))
(define Q3 (make-queue (list->stream '(1)) '(10) 1 1))
(define Q4 (make-queue (list->stream '(1 7)) '(12) 2 1))
(define Q5 (make-queue (list->stream '(2 5 8)) '() 3 0))

(define C1 (empty-counter 1))
(define C2 (empty-counter 2))
(define C3 (empty-counter 3))
(define C4 (empty-counter 4))

(exercițiul 1 : 5 puncte)
(when (struct? empty-queue)
  (check-part 'a .25 (queue-left empty-queue) is empty-stream)
  (check-part 'b .25 (queue-right empty-queue) is '())
  (check-part 'c .25 (queue-size-l empty-queue) is 0)
  (check-part 'd .25 (queue-size-r empty-queue) is 0)
  )

(exercițiul 2 : 5 puncte)
(check-part 'a .2 (queue-empty? Q1) is #t)
(check-part 'b .2 (queue-empty? Q2) is #f)
(check-part 'c .2 (queue-empty? Q3) is #f)
(check-part 'd .2 (queue-empty? Q4) is #f)
(check-part 'e .2 (queue-empty? Q5) is #f)

(exercițiul 3 : 20 puncte)
(check-part 'a .25 (rotate empty-stream '(11) empty-stream)
            (the stream->list is) '(11) (λ (res) (or (stream? res) "nu este un stream")))
(check-part 'b .25 (rotate (list->stream '(1 2 3)) '(7 6 5 4) empty-stream)
            (the stream->list is) '(1 2 3 4 5 6 7) (λ (res) (or (stream? res) "nu este un stream")))
(check-part 'c .25 (rotate (list->stream '(1)) '(3 5) empty-stream)
            (the stream->list is) '(1 5 3) (λ (res) (or (stream? res) "nu este un stream")))
(check-part 'd .25 (rotate (list->stream '(1 2 3)) '(11 12 13 14) (list->stream '(22 33)))
            (the stream->list is) '(1 2 3 14 13 12 11 22 33) (λ (res) (or (stream? res) "nu este un stream")))
  
(exercițiul 4 : 20 puncte)
(check-part 'a .2 (enqueue 'a Q1)
            (the new->legacy is) (queue '(a) '() 1 0) (λ (res) (or (struct? res) "nu este o coadă")))
(check-part 'b .2 (enqueue 'b Q2)
            (the new->legacy is) (queue '(10 2 3 40 5 60 b) '() 7 0) (λ (res) (or (struct? res) "nu este o coadă")))				
(check-part 'c .2 (enqueue 'c Q3)
            (the new->legacy is) (queue '(1 10 c) '() 3 0) (λ (res) (or (struct? res) "nu este o coadă")))				
(check-part 'd .2 (enqueue 'd Q4)
            (the new->legacy is) (queue '(1 7) '(d 12) 2 2) (λ (res) (or (struct? res) "nu este o coadă")))
(check-part 'e .2 (enqueue 'e Q5)
            (the new->legacy is) (queue '(2 5 8) '(e) 3 1) (λ (res) (or (struct? res) "nu este o coadă")))				
  
(exercițiul 5 : 20 puncte)
(check-part 'a .25 (dequeue Q2)
            (the new->legacy is) (queue '(2 3 40 5 60) '() 5 0) (λ (res) (or (struct? res) "nu este o coadă")))
(check-part 'b .25 (dequeue Q3)
            (the new->legacy is) (queue '(10) '() 1 0) (λ (res) (or (struct? res) "nu este o coadă")))				
(check-part 'c .25 (dequeue Q4)
            (the new->legacy is) (queue '(7) '(12) 1 1) (λ (res) (or (struct? res) "nu este o coadă")))				
(check-part 'd .25 (dequeue Q5)
            (the new->legacy is) (queue '(5 8) '() 2 0) (λ (res) (or (struct? res) "nu este o coadă")))
  
(exercițiul 6 : 10 puncte)
(check-part 'a .25 (top Q2) is 10)
(check-part 'b .25 (top Q3) is 1)
(check-part 'c .25 (top Q4) is 1)
(check-part 'd .25 (top Q5) is 2)
 
(exercițiul 7 : 40 puncte)
(when (andmap struct? (list C1 C2 C3 C4))
  (check-part 'a .125 
              (serve '((ana 11) (leo 5) (maia 3) (dan 5) (daria 4) (clara 7) (alin 3) (sonia 5) (adi 4) (florin 7) (horia 1) (anda 2))
                     (list C1)
                     (list C2 C3))
              (the friendly-output is)
              (list
               '()
               (cons 1 (queue '((leo . 5) (daria . 4) (alin . 3)) '((horia . 1) (adi . 4)) 3 2))
               (cons 2 (queue '((ana . 11) (sonia . 5) (anda . 2)) '() 3 0))
               (cons 3 (queue '((maia . 3) (dan . 5) (clara . 7)) '((florin . 7)) 3 1)))
              (λ (res) (or (list? res) "nu este o listă")))
  (check-part 'b .125 
              (serve '((ana 11) 6 (leo 5) 1 (maia 3) (dan 5) 2 (daria 4) 1 (clara 7) 2 (alin 3) 1 (sonia 5) 3 (adi 4) (florin 7) 1 (horia 1) (anda 2) (costin 6) 3)
                     (list C1)
                     (list C2 C3 C4))
              (the friendly-output is)
              (list
               '((3 . maia) (1 . leo) (2 . ana) (4 . dan) (3 . daria) (1 . alin) (2 . clara) (4 . sonia) (2 . horia) (1 . adi) (4 . anda))
               (cons 2 (queue '((costin . 6)) '() 1 0))
               (cons 3 (queue '((florin . 7)) '() 1 0)))
              (λ (res) (or (list? res) "nu este o listă")))
  (check-part 'c .125 
              (serve '((ana 11) 6 (leo 5) 1 (maia 3) (dan 5) 2 (daria 4) (close 2) 1 (clara 7) 2 (alin 3) 1 (sonia 5) 3 (adi 4) (florin 7) 1 (horia 1) (anda 2) (costin 6) 3)
                     (list C1 C2)
                     (list C3 C4))
              (the friendly-output is)
              (list
               '((2 . maia) (1 . leo) (3 . ana) (4 . dan) (2 . daria) (1 . alin) (3 . clara) (4 . sonia) (4 . horia) (1 . adi))
               (cons 3 (queue '((florin . 7)) '() 1 0))
               (cons 4 (queue '((anda . 2)) '((costin . 6)) 1 1)))
              (λ (res) (or (list? res) "nu este o listă")))
  (check-part 'd .125 
              (serve '((ana 10) (leo 5) (maia 4) (dan 5) (daria 5) (close 2) (ensure 5) (clara 7) (alin 3) (sonia 5) (adi 4) (florin 7) (horia 1) (anda 2) (ensure 12) (stela 3))
                     (list C1 C2 C3)
                     (list C4))
              (the friendly-output is)
              (list
               '()
               (cons 1 (queue '((leo . 5) (alin . 3) (horia . 1)) '((anda . 2)) 3 1))
               (cons 2 (queue '((maia . 4)) '((daria . 5)) 1 1))
               (cons 3 (queue '((dan . 5)) '((sonia . 5)) 1 1))
               (cons 4 (queue '((ana . 10)) '((florin . 7)) 1 1))
               (cons 5 (queue '((clara . 7)) '((adi . 4)) 1 1))
               (cons 6 (queue '((stela . 3)) '() 1 0)))
              (λ (res) (or (list? res) "nu este o listă")))
  (check-part 'e .125 
              (serve '((ana 10) 2 (leo 5) 3 (maia 4) (dan 5) 1 (daria 5) (anca 4) (close 2) (ensure 5) 2 (clara 7) (alin 3) 3 (sonia 5) 1 (adi 4) (florin 7) 2 (horia 1) 1 (anda 2) 2 (ensure 3) (stela 7) (alma 10))
                     (list C1 C2 C3)
                     (list C4))
              (the friendly-output is)
              (list
               '((1 . leo) (2 . maia) (3 . dan) (4 . ana) (1 . daria) (2 . anca) (3 . alin) (1 . sonia) (3 . adi) (4 . clara))
               (cons 1 (queue '((horia . 1)) '() 1 0))
               (cons 3 (queue '((anda . 2)) '() 1 0))
               (cons 4 (queue '((florin . 7)) '((alma . 10)) 1 1))
               (cons 5 (queue '((stela . 7)) '() 1 0)))
              (λ (res) (or (list? res) "nu este o listă")))
  (check-part 'f .125 
              (serve '((ana 10) 2 (leo 5) (maia 4) (dan 5) 1 (daria 5) 2 (anca 4) (close 2) 2 (clara 7) 1 (alin 13) 3 (sonia 5) 1 (adi 6) 2 (florin 7) 2 (horia 4) 1 (anda 5) (stela 7) (close 4) 2 (ema 14) 5 (alma 10))
                     (list C1 C2)
                     (list C3 C4))
              (the friendly-output is)
              (list
               '((2 . maia) (1 . leo) (4 . dan) (3 . ana) (1 . anca) (2 . daria) (4 . clara) (1 . sonia) (1 . horia) (4 . adi) (3 . alin))
               (cons 1 (queue '((anda . 5)) '() 1 0))
               (cons 3 (queue '((stela . 7) (ema . 14)) '((alma . 10)) 2 1))
               (cons 4 (queue '((florin . 7)) '() 1 0)))
              (λ (res) (or (list? res) "nu este o listă")))
  (check-part 'g .125 
              (serve '((ana 10) 2 (leo 5) 3 (maia 4) (dan 5) 1 (daria 5) (anca 4) (close 2) (ensure 4) 2 (clara 7) (alin 13) 3 (sonia 5) 1 (adi 6) 2 (florin 7) (close 5) (ensure 3) 2 (horia 4) 1 (anda 5) (stela 7) 3 (ema 14) 1 (alma 10))
                     (list C1 C2 C3)
                     (list C4))
              (the friendly-output is)
              (list
               '((1 . leo) (2 . maia) (3 . dan) (4 . ana) (1 . daria) (2 . anca) (5 . clara) (3 . sonia) (1 . horia) (5 . adi))
               (cons 3 (queue '((anda . 5)) '() 1 0))
               (cons 4 (queue '((alin . 13)) '((ema . 14)) 1 1))
               (cons 5 (queue '((florin . 7)) '() 1 0))
               (cons 6 (queue '((stela . 7)) '((alma . 10)) 1 1)))
              (λ (res) (or (list? res) "nu este o listă")))
  (check-part 'h .125 
              (serve '((ion 10) 3 (gigi 5) 2 (delay 1 5) 1 (delay 3 10) (delay 4 5) 1 (lia 3)
                                (close 2) 2 (dan 3) (ada 7) 2 (nera 4) (close 1) (ensure 6) (milu 8) (leo 1) 4 (delay 3 8) (anca 3))
                     (list C1)
                     (list C2 C3 C4))
              (the friendly-output is)
              (list
               '((2 . ion) (1 . gigi) (2 . lia) (4 . dan))
               (cons 1 (queue '((nera . 4)) '() 1 0))
               (cons 3 (queue '((leo . 1)) '() 1 0))
               (cons 4 (queue '((ada . 7)) '() 1 0))
               (cons 5 (queue '((milu . 8)) '((anca . 3)) 1 1)))
              (λ (res) (or (list? res) "nu este o listă")))
  )

(sumar)